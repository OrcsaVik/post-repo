---
title: 高并发社交平台核心技术架构
---

# 高并发社交平台核心技术架构 · 完整梳理

## 一、统一网关鉴权（Spring Cloud Gateway + Sa-Token）

**核心设计思想**  
网关层统一拦截、校验、透传用户身份，下游服务无状态化、无需重复鉴权。

**关键实现**
- 使用 `SaReactorFilter`（WebFlux 专用）实现全局鉴权过滤器
- 通过 `@Order(-100)` 确保最高优先级执行
- 白名单排除：`/auth/login`, `/auth/verify/code/send`
- 登录校验：`StpUtil.checkLogin()`
- 用户ID透传：`exchange.getRequest().mutate().header("x-user-id", userId).build()`

**Sa-Token 自定义权限接口**（RBAC实现）

```java
public interface StpInterface {
    // 返回当前登录用户所拥有的全部权限码集合
    List<String> getPermissionList(Object loginId, String loginType);
    
    // 返回当前登录用户所拥有的全部角色集合
    List<String> getRoleList(Object loginId, String loginType);
}
```

**底层权限加载逻辑**（Redis + JSON 批量查询）

```java
List<String> roleKeys = objectMapper.readValue(redis.get(userRolesKey), new TypeReference<>() {});
List<String> permissionKeys = roleKeys.stream().map(RedisKey::rolePerms).toList();
List<String> allPermsJson = redisTemplate.opsForValue().multiGet(permissionKeys);
List<String> permissions = allPermsJson.stream()
    .flatMap(json -> objectMapper.readValue(json, new TypeReference<List<String>>(){}).stream())
    .distinct()
    .collect(Collectors.toList());
```

**结论**  
一次校验、全局生效、Header 透传 → 实现分布式无状态认证，极大降低下游服务复杂度。

## 二、分布式ID生成（美团 Leaf）

**两种模式并存**

| 模式      | 核心原理                    | 优点                       | 适用场景         | 吞吐量参考  |
| --------- | --------------------------- | -------------------------- | ---------------- | ----------- |
| Segment   | 数据库号段预分配 + 双Buffer | 高吞吐、无锁、趋势递增     | 主业务ID、订单号 | 单机 22k+/s |
| Snowflake | 时间戳 + 机器ID + 序列号    | 完全去中心化、多机独立生成 | 日志ID、临时ID   | 单机更高    |

**Segment 模式核心机制**（双Buffer + 动态步长）

- 双 SegmentBuffer（当前 + 预取）
- 后台单线程定时从 DB 加载备用段
- 动态步长调整（空闲时步长×2，繁忙时步长减半）
- 切换条件：当前段剩余 < step × 0.9 → 切备用段

**Snowflake 模式核心机制**（Zookeeper 分配 workerId）

- 结构：`[1bit符号][41bit时间戳][10bit机器ID][12bit序列号]`
- workerId 通过 Zookeeper 持久节点 `/snowflake/forever/ip:port-xxx` 分配
- 本地文件缓存 workerId（防止ZK不可用时服务无法启动）
- 时钟回拨处理：等待 + 随机序列号填充

## 三、短文本存储（Apache Cassandra）

**宽表模型设计**（以笔记评论为例）

```sql
CREATE TABLE comment_content (
    note_id         bigint,
    year_month      text,
    content_id      uuid,
    content         text,
    create_time     timestamp,
    PRIMARY KEY ((note_id, year_month), content_id)
) WITH CLUSTERING ORDER BY (content_id ASC);
```

**联合分区键设计目的**

- note_id + year_month 作为复合分区键
- 解决单分区过大 → 数据倾斜
- 按月分区 → 便于归档、清理冷数据

**批量操作特点**

- 批量插入：`cassandraTemplate.batchOps().insert(list).execute()`
- 批量查询：`findByNoteIdAndYearMonthInAndContentIdIn(...)`
- 无事务支持 → 依赖业务补偿或幂等设计

## 四、笔记详情查询性能优化（CompletableFuture + 双级缓存 + MQ广播）

**核心流程**

1. 本地 Caffeine Cache 最高优先级（最快）
2. Redis 共享缓存（跨实例一致）
3. 数据库 + RPC 并行查询（CompletableFuture）
4. 结果异步回写 Redis + 本地缓存（随机过期打散）
5. 更新/删除时 RocketMQ 广播 → 各节点延迟双删本地缓存

**关键设计点**

- 异步并行 RPC：笔记 → 用户 → 内容
- 防缓存雪崩：基础过期时间 + 随机秒数
- 最终一致性：MQ广播 + 延迟双删

## 五、点赞高并发写优化（Redis BloomFilter + ZSET + RocketMQ + RateLimiter）

**防重复点赞**：Redis BloomFilter + Roaring Bitmap  
**点赞记录**：`zadd like:user:{userId} {timestamp} {noteId}`  
**削峰落库**：MQ异步 → RateLimiter限流 → 批量插入  
**幂等合并**：消费端按 userId + noteId 分组 → 只保留最后一次操作（奇偶过滤）

**批量落库 SQL**（MyBatis）

```xml
<insert id="batchInsertOrUpdate">
    INSERT INTO t_note_like (user_id, note_id, status, create_time)
    VALUES
    <foreach collection="list" item="item" separator=",">
        (#{item.userId}, #{item.noteId}, #{item.status}, #{item.createTime})
    </foreach>
    ON DUPLICATE KEY UPDATE status = VALUES(status)
</insert>
```

## 六、计数聚合与流量削峰（RocketMQ + BufferTrigger + Redis）

**核心链路**

1. 业务操作 → 发 MQ（关注/点赞等）
2. 消费者接收 → BufferTrigger 聚合（1000条/批 or 1s）
3. 聚合后批量 increment Redis Hash（原子性）
4. 定时/定量批量刷库（RateLimiter限流）

**BufferTrigger 关键能力**

- 内存缓冲 + 批量触发（大小/时间/手动）
- simple（非阻塞） vs batchBlocking（阻塞、有序、限流）
- 生产推荐：**batchBlocking**

**总结一句话**  
高并发写 → 先写内存聚合 → Redis 原子计数 → 异步削峰落库 → 最终一致性

## 七、整体架构技术选型对比

| 领域          | 技术选型                        | 核心优势                         | 主要解决的问题        |
| ------------- | ------------------------------- | -------------------------------- | --------------------- |
| 网关鉴权      | Spring Cloud Gateway + Sa-Token | 统一入口、Header透传、无状态下游 | 重复认证、耦合度高    |
| 分布式ID      | 美团 Leaf (Segment + Snowflake) | 高吞吐、趋势递增、容灾           | 全局唯一ID生成瓶颈    |
| 长文本/短文本 | Cassandra                       | 海量宽表、高可用、水平扩展       | 亿级评论/笔记内容存储 |
| 高并发点赞    | Redis Bloom + ZSET + MQ + Rate  | 防重、削峰、幂等合并             | 点赞写库压力          |
| 计数聚合      | BufferTrigger + Redis Hash + MQ | 聚合写、原子计数、最终一致性     | 高频计数写库崩溃      |
| 缓存一致性    | 二级缓存 + MQ广播延迟双删       | 读性能极致、写最终一致           | 缓存与数据库不一致    |

**架构指导思想**  
“**先写内存 → 聚合批量 → 异步削峰 → 最终一致**”  
是整个高并发社交平台最核心的性能与稳定性平衡之道。
```