---
title: 接口防止盗刷和是否存在注册用户
description: 涵盖高并发用户名校验、布隆过滤器应用、登录安全防护及延时任务处理
---

# 接口防止盗刷和是否存在注册用户
## 一、 高效对象映射与转换

在微服务开发中，DTO 与 Entity 的频繁转换是性能损耗点。利用 `Optional` 结合高效的 `BeanMapper`（如 MapStruct 或自定义反射构建器）可以提升代码健壮性。



```Java
public static <T, S> List<T> convertList(List<S> sources, Class<T> clazz) {
    return Optional.ofNullable(sources)
            .map(each -> {
                List<T> targetList = new ArrayList<>(each.size());
                each.forEach(item -> targetList.add(BEAN_MAPPER_BUILDER.map(item, clazz)));
                return targetList;
            })
            .orElse(Collections.emptyList());
}
```

------

## 二、 海量用户名查重与缓存优化

### 1. 传统查询痛点

当大量注册/查询请求涌入时，若缓存未命中（Miss），压力将直接打到数据库。

### 2. 布隆过滤器 (Bloom Filter) + Set 复用机制

为了解决数据库击穿并支持**注销用户名的重新分配**，设计如下：

- **第一层：布隆过滤器**
  - **判定不存在**：用户名绝对未注册，可直接使用。
  - **判定存在**：可能已注册（误判）或确实已注册，需进入下一层。
- **第二层：Redis Set (注销库)**
  - 存放已注销但可被复用的用户名。
  - 若 Set 中存在，则该名称可用；若不存在，说明已被他人占用。

### 3. Redis 大 Key 与原子性处理

::: warning 风险：大 Key 问题

若注销用户过多导致单 Set 记录过载，会引发 Redis 阻塞。

- **拆分策略**：基于 `hashCode % N` 将大 Set 划分为多个小子集（Sub-Set）。

- **删除优化**：使用 `UNLINK` 异步删除大 Key，避免 `DEL` 导致的同步阻塞。

- 原子操作：通过 Lua 脚本 封装“校验-获取-删除”逻辑，保证并发安全。

  :::

------

## 三、 登录安全与性能防护

### 1. 验证码发送限流 (滑动窗口)

防止接口盗刷消耗短信成本，使用自定义注解实现细粒度控制。



```Java
// 限制 60 秒内同一手机号最多请求 5 次
@RateLimiter(key = "login:verify:#{#phone}", rate = 5, interval = 60)
public String sendVerifyCode(String phone) {
    // 逻辑实现...
}
```

### 2. 密码安全与风控表设计

通过“加盐哈希”与“动态锁定”机制对抗暴力破解。

| **字段**         | **说明**     | **作用**                       |
| ---------------- | ------------ | ------------------------------ |
| `password_hash`  | 强哈希加密值 | 即使数据库泄露也无法还原明文。 |
| `salt`           | 随机盐值     | 防范彩虹表攻击。               |
| `fail_count`     | 连续失败次数 | 触发图形验证码或账户暂时锁定。 |
| `last_fail_time` | 最后失败时间 | 用于计算锁定解锁时间窗口。     |

------

## 四、 延时任务与队列处理

### 1. DelayQueue 机制

用于处理“超时未支付自动释放用户名”或“注销延迟生效”等场景。

- **实现接口**：元素需实现 `Delayed` 接口并重写 `getDelay` 方法。
- **调度方式**：
  - **JVM 内置**：`DelayQueue` 配合 `SpringTask` 定时消费。
  - **分布式**：使用 Redis `zset` 或 RabbitMQ 死信队列。



```Java
@Scheduled(fixedRate = 10000)
public void processTask() {
    DelayTask task = delayQueue.poll();
    if (task != null) {
        // 执行业务逻辑
    }
}
```

------

## 五、 项目核心功能模块树

Plaintext

```
刚果商城-用户中心
├─ 1. 用户认证模块
│  ├─ 1.1 登录/注册（Bcrypt 加密 + 随机盐）
│  ├─ 1.2 验证码机制（滑动窗口限流、图形验证码）
│  └─ 1.3 注销流程（逻辑删除 + 用户名进入复用池）
├─ 2. 缓存与性能层
│  ├─ 2.1 布隆过滤器（拦截无效注册查询）
│  ├─ 2.2 Redis 分片 Set（管理注销用户名，避免大 Key）
│  └─ 2.3 Lua 脚本原子核销（保证高并发复用安全）
├─ 3. 安全防护模块
│  ├─ 3.1 接口防刷（AOP + Redis 自定义注解）
│  └─ 3.2 账户风控（失败计数锁定、异常登录提醒）
└─ 4. 任务调度中心
   ├─ 4.1 异步邮件/短信（线程池优化）
   └─ 4.2 延时任务（超时资源释放、异步注销执行）
```

------

## 🔗 技术要点回顾

- **异步机制**：必须开启 `@EnableAsync`，确保邮件/短信不阻塞主线程。
- **流量控制**：Nginx (接入层) -> Sentinel (应用层) -> RateLimiter (方法层) 构建多维防御。
- **数据一致性**：利用 Lua 脚本解决 Redis 并发竞争。

